

>常用的数据结构可根据数据访问的特点分为**线性结构**和**非线性结构**。
>
>线性结构包括常见的链表、栈、队列等，非线性结构包括树、图等。

## 数组

数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。**数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小**。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mn06k3sj30lt0h5gm7.jpg)

## 链表

链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。

由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。

一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mnu0dqgj30qx0e274u.jpg)

**链表和数组对比**

链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mp6ri26j30fa09n3yg.jpg)



## 跳表

链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，**通过增加链表的多级索引来加快原始链表的查询效率**。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5mqrxeagj30u00ceq3l.jpg)

从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。

> 跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。
>
> 

## 栈和队列

### 栈

**特点：**栈的最大特点就是**后进先出（LIFO）**。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。

**实现：**利用一个**单链表**来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成。

**应用场景：**在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。

### 队列

**特点：**和栈不同，队列的最大特点是**先进先出（FIFO）**，就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。

**实现：**可以借助**双链表**来实现队列。双链表的头指针允许**在队头查看和删除数据**，而双链表的尾指针允许我们**在队尾查看和添加数据**。

**应用场景：**直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。

#### 双端队列

**特点：**双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。

**实现：**与队列相似，我们可以利用一个**双链表**实现双端队列。

**应用场景：**双端队列最常用的地方就是实现一个**长度动态变化的窗口或者连续区间**，而动态窗口这种数据结构在很多题目里都有运用。

#### 优先队列（Priority Queue）

**特点：**能保证每次取出的元素都是队列中优先级别最高的。优先级别可以是**自定义**的，例如，数据的数值越大，优先级越高；或者数据的数值越小，优先级越高。优先级别甚至可以通过各种复杂的计算得到。

**应用场景：**从一堆杂乱无章的数据当中按照定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据。

**实现：**优先队列的本质是一个二叉堆结构。堆在英文里叫 Binary Heap，它是利用一个数组结构来实现的**完全二叉树**。换句话说，优先队列的本质是一个数组，数组里的每个元素既有可能是其他元素的父节点，也有可能是其他元素的子节点，而且，每个父节点只能有两个子节点，很像一棵二叉树的结构。

> 牢记三个重要的性质：
>
> 1. 数组里的第一个元素 arrays[0]拥有最高的优先级别
> 2. 给定一个下标i，那么对于元素array[i]而言:
>    - 它的父节点所对应的元素下标是(i-1)/2
>    - 它的左孩子所对应的元素下标是2*i+1
>    - 它的右孩子所对应的元素下标是2*i+2
> 3. 数组里每个元素的优先级别都要高于它两个孩子的优先级别

优先队列最基本的操作有两个

**向上筛选**

1. 当有新的数据加入到优先队列中，新的数据首先被放置在二叉堆的底部。
2. 不断进行向上筛选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pji7rupg31400m8e82.gif)

**时间复杂度：**由于二叉堆是一棵完全二叉树，并假设堆的大小为k，因此整个过程其实就是沿着树的高度往上爬，所以只需要O(log k)的时间。

**向下筛选**

1. 当堆顶的元素被取出时，要更新堆顶的元素来作为下一次按照优先级顺序被取出的对象，需要将堆底部的元素放置到堆顶，然后不断地对它执行向下筛选的操作。
2. 将该元素和它的两个孩子节点对比优先级，如果优先级最高的是其中一个孩子，就将该元素和那个孩子进行交换，然后反复进行下去，直到无法继续交换为止。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjjm5lsg31400m8x6p.gif)

**时间复杂度：**整个过程就是沿着树的高度往下爬，所以时间复杂度也是O(log k）

因此，无论是添加新的数据还是取出堆顶的元素，都需要O(log k)的时间。

**初始化**

优先队列的初始化是一个**最重要**的时间复杂度，是分析运用优先队列性能时必不可少的，也是经常容易弄错的地方。

**误区：**每当把—个数据加入到堆里，都要对其执行向上筛选的操作，这样一来就是O(n log n)。

**解法：**在创建这个堆的过程中，二叉树的大小是从1逐渐增长到n的，所以整个算法的复杂度经过推导，最终的结果是O(n)。

注意：算法面试中是不要求推导的，你只需要记住，初始化大小为n的堆，所需要的时间是O（n）即可。

## 树

树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树。

正因为树有这样的性质，大部分关于树的面试题都与递归有关，换句话说，面试官希望通过一道关于树的问题来考察对于递归算法掌握的熟练程度。

### 树的形状

在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。

对于一些特殊的树，例如红黑树（Red-Black Tree）、自平衡二叉搜索树（AVL Tree），一般在面试中不会被问到，除非你所涉及的研究领域跟它们相关或者你十分感兴趣，否则不需要特别着重准备。

关于树的考题，无非就是要考查**树的遍历**以及**序列化（serialization)**。



树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。

树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。

这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5myyuj3rj30u00eidgm.jpg)

别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。

树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5myyf1olj30u00bb74t.jpg)

> **完全二叉树**：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。

> **满二叉树**：除了最后一层，其它层的结点都有两个子结点。

### 平衡二叉树

平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：**它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。**

> **二叉排序树**：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。

> **树的高度**：结点层次的最大值

> **平衡因子**：左子树高度 - 右子树高度

二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点<根节点<右结点，这表明二叉排序树的中序遍历结果是有序的。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n06ws0jj30u00dwjrn.jpg)

平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n0a0wj0j30u00eswf3.jpg)

平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。

> 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用**单旋转**进行平衡化，如果这三个结点位于一条折线上，则采用**双旋转**进行平衡化。

左旋：S为当前需要左旋的结点，E为当前结点的父节点。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n09ipk8j30u00c3q3d.jpg)

左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。可用动画表示：

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n089doxg309506pjxv.gif)

右旋：S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n0ai309j30u00bmaah.jpg)

左旋的操作同样可以用一句话简单表示：将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。可用动画表示：

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n098i9eg308d076te7.gif)



### 树的遍历

#### 前序遍历（Preorder Traversal）

**方法：**先访问根节点，然后访问左子树，最后访问右子树。在访问左、右子树的时候，同样，先访问子树的根节点，再访问子树根节点的左子树和右子树，这是一个不断递归的过程。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjmttggg31hc0p0hdz.gif)



**应用场景：**运用最多的场合包括在树里进行**搜索**以及**创建一棵新的树**。

#### 中序遍历（Inorder Traversal）

**方法：**先访问左子树，然后访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右边。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjqntv9g31hc0p04qz.gif)

**应用场景：**最常见的是**二叉搜素树**，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。

#### 后序遍历（Postorder Traversal）

**方法：**先访问左子树，然后访问右子树，最后访问根节点。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pjv2qjkg31hc0p0u17.gif)

**应用场景：**在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。

**注意：**

掌握好这三种遍历的**递归写法**和**非递归写法**是非常重要的，懂得分析各种写法的**时间复杂度**和**空间复杂度**同样重要。

无论是前端工程师，还是后端工程师，在准备面试的时候，树这个数据结构都是最应该花时间学习的，既能证明你对递归有很好的认识，又能帮助你学习图论。树的许多性质都是面试的热门考点，尤其是**二叉搜索树（BST）**`（二叉搜索树的性质：对于每个节点来说，该节点的值比左孩子大，比右孩子小，而且一般来说，二叉搜索树里不出现重复的值）`。

## 堆

堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此**堆总是一颗完全二叉树**。

对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此**可以直接用数组来表示一个堆**。

不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n53cwyuj30u00gwgmz.jpg)

**堆常用来实现优先队列**，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。

## 散列表

散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，**通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率**。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n6hytm0j30u00aw0ta.jpg)

散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：

> **直接寻址法**：取关键字或关键字的某个线性函数值为散列地址。
>
> **数字分析法**：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。
>
> **平方取中\****法**：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。
>
> **取随机数法**：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。
>
> **除留取余法**：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。

确定好散列函数之后，通过某个`key`值的确会得到一个唯一的`value`地址。但是却会出现一些特殊情况。即通过不同的`key`值可能会访问到同一个地址，这个现象称之为**冲突**。

冲突在发生之后，当在对不同的`key`值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。

常用的冲突处理方式有很多，常用的包括以下几种：

> **开放地址法**（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。
>
> **再哈希法**：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。
>
> **链地址法**：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。
>
> **公共溢出区**：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。

目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n6irtgfj30u00fn0ts.jpg)

左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。

考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。

## 图

### **基本知识点**

图可以说是所有数据结构里面知识点最丰富的一个，最基本的知识点如下：

- 阶、出度、入度
- 树、森林、环
- 有向图、无向图、完全有向图、完全无向图
- 连通图、连通分量
- 存储和表达方式：邻接矩阵、邻接链表

根据长期的经验总结，以下的知识点是必须充分掌握并反复练习:

### 基本存储方式

#### 邻接链表（Adjacency List）

**无向图 graph 表示**

**有向图 digraph 表示**

#### 邻接矩阵（ Adjacency Matrix）

**无向图 graph 表示**

**有向图 digraph 表示**

> 若采用邻接矩阵表示，则需要申请空间大小为 ![|V|^2](https://math.jianshu.com/math?formula=%7CV%7C%5E2) 的二维数组，在二位数组中保存每两个顶点之间的连通关系，则无论有向图或无向图，邻接矩阵方式的存储**空间复杂度皆为** ![O(|V|^2)](https://math.jianshu.com/math?formula=O(%7CV%7C%5E2))。若只记录图中顶点是否连通，不记录权值大小，则可以使用一个二进制位来表示二维数组的每个元素，并且根据无向图的特点可知，**无向图的邻接矩阵沿对角线对称，所以可以选择记录一半邻接矩阵的形式来节省空间开销**。

**两种存储结构对比**

根据邻接表和邻接矩阵的结构特性可知，当图为稀疏图、顶点较多，即图结构比较大时，更适宜选择邻接表作为存储结构。当图为稠密图、顶点较少时，或者不需要记录图中边的权值时，使用邻接矩阵作为存储结构较为合适。

图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8bscfej30u00c80t7.jpg)

图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。

#### 邻接矩阵接矩阵

通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8b3xjvj30u00draan.jpg)

**无向图的邻接矩阵是一个对称矩阵**，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8cafa9j30u00dp0tc.jpg)

有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。

用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。

而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。

因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。

#### 邻接表

在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8dbwg2j30u00e1wf3.jpg)在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B->A->E，其它顶点亦如此。

通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。

> 入度：有向图的某个顶点作为终点的次数和。
>
> 出度：有向图的某个顶点作为起点的次数和。

由此看出，**在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度**。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。

#### 逆邻接表

逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8duj3aj30u00ecmxs.jpg)

**邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示**。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。

#### 十字链表

十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8cu3gpj30u00drdgw.jpg)

但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。

十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）

> **data**：用于存储该顶点中的数据；
>
> **firstin指针**：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；
>
> **firstout指针**：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；

边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：

> **tailvex**：用于存储作为弧尾的顶点的编号；
>
> **headvex**：用于存储作为弧头的顶点的编号；
>
> **headlink** **指针**：用于链接下一个存储作为弧头的顶点的节点；
>
> **taillink** **指针**：用于链接下一个存储作为弧尾的顶点的节点；

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5n8bf0flj30u00ek0u2.jpg)

以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边`AE`（即边04）指向顶点E，顶点A的`firstout`指针需要指向边04的`tailvex`。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边`AB`（即边10）指向B，顶点A的`firstin`指针需要指向边10的弧头，即`headlink`指针。依次类推。

十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看多练，弄清指针指向的意义，明白正向和逆向邻接表的表示。



### 图的遍历

#### 深度优先搜索（Depth-First Search / DFS）

深度优先搜索，从起点出发，从规定的方向中选择其中一个不断地向前走，直到无法继续为止，然后尝试另外一种方向，直到最后走到终点。就像走迷宫一样，尽量往深处走。

**DFS 解决的是连通性的问题，即给定两个点，一个是起始点，一个是终点，判断是不是有一条路径能从起点连接到终点**。起点和终点，也可以指的是某种起始状态和最终的状态。**问题的要求并不在乎路径是长还是短，只在乎有还是没有**。有时候题目也会要求把找到的路径完整的打印出来。

**DFS 遍历**

对这个图进行深度优先的遍历：

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkikpvtj30lo07agm5.jpg)

**解题思路**

必须依赖**栈（Stack）**，特点是**后进先出（LIFO）**。

第一步，选择一个起始顶点，例如从顶点 A 开始。把 A 压入栈，标记它为访问过（用红色标记），并输出到结果中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkjlqq5g31hc0p0npd.gif)

第二步，寻找**与 A 相连**并且还**没有被访问过**的顶点，顶点 A 与 B、D、G 相连，而且它们都还没有被访问过，我们按照**字母顺序**处理，所以将 B 压入栈，标记它为访问过，并输出到结果中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkm7y06g31hc0p0qv6.gif)

第三步，现在我们在顶点 B 上，重复上面的操作，由于 B 与 A、E、F 相连，如果按照字母顺序处理的话，A 应该是要被访问的，但是 **A 已经被访问**了，所以我们访问顶点 E，将 E 压入栈，标记它为访问过，并输出到结果中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkpueksg31hc0p01ky.gif)

第四步，从 E 开始，E 与 B、G 相连，但是B刚刚被访问过了，所以下一个被访问的将是G，把G压入栈，标记它为访问过，并输出到结果中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkr4of1g31hc0p0b2a.gif)

第五步，现在我们在顶点 G 的位置，由于**与 G 相连的顶点都被访问过**了，类似于我们走到了一个死胡同，必须尝试其他的路口了。所以我们这里要做的就是简单地**将 G 从栈里弹出**，表示我们从 G 这里已经无法继续走下去了，看看能不能从前一个路口找到出路。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pksjmsug31hc0p07u8.gif)

> 可以看到，每次我们在考虑下一个要被访问的点是什么的时候，如果发现周围的顶点都被访问了，就把当前的顶点弹出。

第六步，现在栈的顶部记录的是顶点 E，我们来看看与 E 相连的顶点中有没有还没被访问到的，发现它们都被访问了，所以把 E 也弹出去。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pktes4kg31hc0p01kx.gif)

第七步，当前栈的顶点是 B，看看它周围有没有还没被访问的顶点，有，是顶点 F，于是**把 F 压入栈**，标记它为访问过，并输出到结果中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkvfz1hg31hc0p0b2c.gif)

第八步，当前顶点是 F，与 F 相连并且还未被访问到的点是 C 和 D，按照字母顺序来，下一个被访问的点是 C，将 C 压入栈，标记为访问过，输出到结果中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pkybm5pg31hc0p0u0z.gif)

第九步，当前顶点为 C，与 C 相连并尚未被访问到的顶点是 H，将 H 压入栈，标记为访问过，输出到结果中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl03gzfg31hc0p0e84.gif)

第十步，当前顶点是 H，由于和它相连的点都被访问过了，将它弹出栈。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl2k7m0g31hc0p0x6q.gif)

第十一步，当前顶点是 C，与 C 相连的点都被访问过了，将 C 弹出栈。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl4blmyg31hc0p0npe.gif)

第十二步，当前顶点是 F，与 F 相连的并且尚未访问的点是 D，将 D 压入栈，输出到结果中，并标记为访问过。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl5o2dkg31hc0p0kjm.gif)

第十三步，当前顶点是 D，与它相连的点都被访问过了，将它弹出栈。以此类推，顶点 F，B，A 的邻居都被访问过了，将它们**依次弹出栈**就好了。最后，**当栈里已经没有顶点需要处理了，我们的整个遍历结束**。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl7b5bwg31hc0p0npf.gif)

**算法分析**

DFS 是图论里的算法，分析利用 DFS 解题的复杂度时，应当借用图论的思想。图有两种表示方式：邻接表、邻接矩阵。假设图里有 V 个顶点，E 条边。

**时间复杂度：**

- 邻接表

  访问所有顶点的时间为 O(V)，而查找所有顶点的邻居一共需要 O(E) 的时间，所以总的时间复杂度是 **O(V + E)**。

- 邻接矩阵

  查找每个顶点的邻居需要 O(V) 的时间，所以查找整个矩阵的时候需要 **O(V²)** 的时间。

**空间复杂度：**

DFS 需要**堆栈**来辅助，在最坏情况下，得把所有顶点都压入堆栈里，所以它的空间复杂度是 **O(V)**。

#### 广度优先搜索（Breadth-First Search / BFS）

广度优先搜索，一般用来解决**最短路径**的问题。和深度优先搜索不同，广度优先的搜索是从起始点出发，一层一层地进行，每层当中的点距离起始点的步数都是相同的，当找到了目的地之后就可以立即结束。

广度优先的搜索可以同时从起始点和终点开始进行，称之为**双端 BFS**。这种算法往往可以大大地提高搜索的效率。

**BFS 遍历**

对这个图进行广度优先的遍历：

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl8dhgrj30lo07amxp.jpg)

**解题思路**

依赖**队列（Queue）**，**先进先出（FIFO）**。一层一层地把与某个点相连的点放入队列中，处理节点的时候正好按照它们进入队列的顺序进行。

第一步，选择一个起始顶点，让我们从顶点 A 开始。把 A 压入队列，标记它为访问过（用红色标记）。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pl9uwyag31hc0p04qq.gif)

第二步，从队列的头取出顶点 A，打印输出到结果中，同时将**与它相连**的**尚未被访问过**的点按照**字母大小顺序**压入队列，同时把它们都标记为访问过，防止它们被重复地添加到队列中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plcbbsfg31hc0p0b2c.gif)

第三步，从**队列的头**取出顶点 B，打印输出它，同时将与它相连的尚未被访问过的点（也就是 E 和 F）压入队列，同时把它们都标记为访问过。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pletvd7g31hc0p07wn.gif)

第四步，继续从队列的头取出顶点 D，打印输出它，此时我们发现，与 D 相连的顶点 A 和 F 都被标记访问过了，所以就不要把它们压入队列里。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plgfn9qg31hc0p0x6q.gif)

第五步，接下来，队列的头是顶点 G，打印输出它，同样的，G 周围的点都被标记访问过了。我们不做任何处理。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pliczz6g31hc0p0hdv.gif)

第六步，队列的头是 E，打印输出它，它周围的点也都被标记为访问过了，我们不做任何处理。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4pljpkvng31hc0p0e81.gif)

第七步，接下来轮到顶点 F，打印输出它，将 C 压入队列，并标记 C 为访问过。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plm8b90g31hc0p0npe.gif)

第八步，将 C 从队列中移出，打印输出它，与它相连的 H 还没被访问到，将 H 压入队列，将它标记为访问过。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plnm5iog31hc0p07wi.gif)

第九步，队列里只剩下 H 了，将它移出，打印输出它，发现它的邻居都被访问过了，不做任何事情。

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4plotsqwg31hc0p0u0x.gif)

第十步，**队列为空，表示所有的点都被处理完毕了**，程序结束。

**算法分析**

同样借助图论的分析方法，假设有 V 个顶点，E 条边。

**时间复杂度：**

- 邻接表

  每个顶点都需要被访问一次，时间复杂度是 O(V)；相连的顶点（也就是每条边）也都要被访问一次，加起来就是 O(E)。因此整体时间复杂度就是 **O(V+E)**。

- 邻接矩阵

  V 个顶点，每次都要检查每个顶点与其他顶点是否有联系，因此时间复杂度是 **O(V²)**。

**空间复杂度：**

需要借助一个队列，所有顶点都要进入队列一次，从队列弹出一次。在最坏的情况下，空间复杂度是 **O(V)**。













