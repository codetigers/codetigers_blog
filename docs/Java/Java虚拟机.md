# Java虚拟机

## JVM 的主要组成部分

![JVM主要组成部分](https://tva1.sinaimg.cn/large/007S8ZIlly1gf004cfo6tj30y90jnjxw.jpg)

JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

- Class loader(类装载)：根据给定的全类名(如：java.lang.Object)来装载class文件到运行时区域中的方法区。
- Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。
- Execution engine(执行引擎)：执行class中的指令。
- Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。

## 运行时数据区域

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5togp3xij30kd0sl0uh.jpg)

不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：

### 程序计数器

当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。

### 虚拟机栈

每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

### 本地方法栈

与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

### 堆

Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存，也是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

- 新生代（Young Generation）
- 老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

#### 堆和栈的区别

1. 物理地址
   - 堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。
   - 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。
2. 内存分别
   - 堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。
   - 栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。
3. 存放的内容
   - 堆存放的是对象的实例和数组。因此该区更关注的是数据的存储
   - 栈存放：局部变量，操作数栈，返回结果。更关注的是程序方法的执行。
4. 程序的可见度
   - 堆对于整个应用程序都是共享、可见的。
   - 栈只对于线程是可见的，所以也是线程私有，生命周期和线程相同。

### 方法区

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。

#### 运行时常量池

运行时常量池是方法区的一部分。

Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。

除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

### 直接内存

在 JDK 1.4 中新引入了 NIO 类，它可以将本地方法库直接分配到堆外内存，然后通过堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

## 垃圾收集

### 内存泄漏

内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。

但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。

### 垃圾回收机制

垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。

### 判断一个对象是否可被回收

#### 1. 引用计数算法

为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

在两个对象出现**循环引用**的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

```java
public class Test {
    public Object instance = null;
    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
    }
} 拷贝到剪贴板拷贝失败拷贝成功
```

在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。

#### 2. 可达性分析算法

采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：

- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

### 类的卸载

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

### finalize()函数

类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。

### 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 提供了四种强度不同的引用类型。

#### 1. 强引用

被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object(); 拷贝到剪贴板拷贝失败拷贝成功
```

#### 2. 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联 拷贝到剪贴板拷贝失败拷贝成功
```

#### 3. 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null; 拷贝到剪贴板拷贝失败拷贝成功
```

#### 4. 虚引用

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

使用 PhantomReference 来创建虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null; 拷贝到剪贴板拷贝失败拷贝成功
```

### 垃圾收集算法

#### 标记 - 清除

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tqwqbz6j30ia0a90st.jpg)

标记无用对象，然后进行清除回收。

标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：

1. 标记阶段：标记出可以回收的对象。
2. 清除阶段：回收被标记的对象所占用的空间。

标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。

- 优点：实现简单，不需要对象进行移动。
- 缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。

#### 复制

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tslijnej30i209f0su.jpg)

为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。

- 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
- 缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

#### 标记 - 整理

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tsnco95j30ia09r0st.jpg)

在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。

- 优点：解决了标记-清理算法存在的内存碎片问题。
- 缺点：仍需要进行局部对象移动，一定程度上降低了效率。

#### 分代收集

当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块，一般包括年轻代和老年代。

一般将堆分为新生代和老年代。

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法

### 垃圾收集器

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tspm8g3j30hy0av0td.jpg)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

新生代垃圾回收器一般采用的是复制算法；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。

1. Serial收集器 (复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
2. ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
3. Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
4. Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
5. Parallel Old收集器 (标记-整理算法): 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
6. CMS(Concurrent Mark Sweep)收集器 (标记-清除算法): 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间；
7. G1(Garbage First)收集器 (标记-整理算法): Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

### 分代垃圾回收器的工作过程

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8![1](https://github.githubassets.com/images/icons/emoji/1.png)1，它的执行流程如下：

1. 把 Eden + From Survivor 存活的对象放入 To Survivor 区；
2. 清空 Eden 和 From Survivor 分区；
3. From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。

## 内存分配与回收策略

### Minor GC 和 Full GC

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

### 内存分配策略

#### 1. 对象优先在 Eden 分配

多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

#### 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。

#### 3. 长期存的对象进入老年代

虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。

#### 4. 动态对象年龄判

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

#### 5. 空间分配担保机制

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

### Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

#### 1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

#### 2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

#### 3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。

#### 4. JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

#### 5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

## 虚拟机类加载机制

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类，因为如果一次性加载，那么会占用很多的内存。

Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。

**类装载方式：**

1. 隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中
2. 显式装载， 通过class.forname()等方法，显式加载需要的类

**类装载过程：**

1. 通过编译器把 Java 代码转换成字节码
2. 类加载器把字节码加载到内存中，将其放在运行时数据区的方法区内
3. 字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口来实现整个程序的功能

### 类装载的执行过程

![img](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5tsut5fnj30u50750ta.jpg)

类装载分为以下 5 个步骤：

1. 加载：根据查找路径找到相应的 class 文件然后导入；
2. 验证：检查加载的 class 文件的正确性；
3. 准备：给类中的静态变量分配内存空间；
4. 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；
5. 初始化：对静态变量和静态代码块执行初始化工作。

### 双亲委派模型

在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据全类名将 class 文件加载到 JVM 内存，然后再转化为 class 对象。

**类加载器分类**

- 启动类加载器（Bootstrap ClassLoader）：是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；

其他类加载器：

- 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；
- 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器**默认**就是用这个加载器。

**双亲委派模型**

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。

**好处**

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

> 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

### 类初始化时机

#### 1. 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：

- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候；
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化；
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

#### 2. 被动引

以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。

```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义 拷贝到剪贴板拷贝失败拷贝成功
```

- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。

```java
SuperClass[] sca = new SuperClass[10]; 拷贝到剪贴板拷贝失败拷贝成功
```

- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

```java
System.out.println(ConstClass.HELLOWORLD); 
```

### 垃圾回收器

#### 1.CMS回收器(concurrent mark sweep)并发标记清除

>简介:是一种以获取最短回收停顿时间为目标的收集器

>步骤:
>
>1. 初始标记(STW)
>2. 并发标记
>3. 重新标记(STW)
>4. 并发清除

1.初始标记:只是标记一下GC Roots能直接关联到的对象，速度很快

2.并发标记:从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时比较长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

3.重新标记:是为了修正并发标记期间，**因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿通常会比初始阶段稍长一点，但也远比并发标记的时间短。

4.并发清楚阶段:清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活的对象，因此可以与用户线程同时并发的。

由于在整个过程中耗时最长的并发标记和并发清楚阶段中，垃圾收集线程和用户线程是可以一起执行的，所以吗，从总体上来说，CMS收集的内存回收过程是与用户线程一起并发执行的。

>缺点:
>
>1. CMS收集器对处理器资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分回收线程而导致应用程序变慢，降低总的吞吐量。
>2. 由于CMS收集器无法处理浮动垃圾，有可能出现:"Concurrent Mode Failure"失败进而导致另一次完全的"stop the world"的Full GC。在CMS并发标记和并发清理阶段，用户的线程是还在继续运行的，程序在运行自然就还会伴随着有新垃圾的生成，但这一部分的垃圾对象是出现在标记过程结束之后的，CMS无法在当次收集中处理掉他们，只好留待下一次垃圾收集时再清除掉。这一部分的垃圾就称为**浮动垃圾**
>3. 因为CMS收集器最终清除垃圾的方法是清除法，因此清除后会导致老年代有很多的空间碎片，容易导致Full GC,可以设置相关虚拟机参数来设置对老年代内存进行整理。

#### 2.G1(Garbage First)

> 简介:G1可以面向堆内存中任何部分来组成回收集就(Collection Set)进行回收，衡量标准不再是它属于哪个分代，而是那块内存中存放的垃圾数量多，回收收益最大，这就是G1收集器的Mixed GC模式

> G1开创的基于Region的堆内存布局是它能够实现这个目标的关键，虽然G1也仍然是遵循分代收集理论设计的。但其堆内存的布局与其它收集器有非常明显的差异:G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的堆内存划分为多个大小相等的独立区域，每一个Region都可以根据需要，扮演新生代的Eden区域,Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间，熬过多次收集的旧对象都能起到很好的收集效果。
>
> Region还有一类特殊的区域Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量的一半的对象就可以判断为大对象。而对于那些超过了整个Region区域的大对象，就会使用连续的Humongous之中，并将其以老年带来看待。
>
> 虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不是固定的了，他们都是一系列区域(不需要连续)的动态集合.G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的 内存空间都是Region大小的整数倍，这样就可以有计划的避免在整个Java堆中进行全区域的垃圾收集。
>
> 具体来说就是:
>
> 让G1收集器去跟踪各个Region里面的垃圾堆积的价值大小，价值就是回收所获得的空间大小以及回收所需要的时间的经验，然后在后台维护一个优先级列表，每次根据用户设置的允许收集停顿时间，优先处理回收价值受益最大的那些Region,这也就是"garbage first"的由来。这样的收集方法保证了G1收集器在有限时间内获取尽可能高的收集效益。

> G1收集器存在的缺点有:《深入理解Java虚拟机》P100

> 步骤:
>
> 1. 初始标记:仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用的Region中分配新的对象。这个阶段需要停顿线程，但是耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。(G1为每一个Region设计了两个名为TAMS(Top at Mark Start)的指针，把Region中的一部分空间划分出来用与并发回收过程中的新对象的分配，并发回收时新分配的对象地址都必须在这两个指针位置上)
> 2. 并发标记:从GC Roots开始对堆中对象进行可达性分析，递归的扫描这个堆中的对象图，找出要回收的对象，这个阶段耗时比较长，但可与用户程序并发执行，当对象扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
> 3. 最终标记:对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的那少量的SATB(原始快照搜索)记录
> 4. 筛选回收:负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由地选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间。因为这里的操作涉及存活对象的移动，是必须暂停用户线程。

> 优点:
>
> 1. 可以指定最大停顿时间，分Region的内存布局，按收益动态确定回收集
> 2. 与CMS回收时采用的标记-清除不同，G1从整体上来看是基于标记-整理算法实现的收集器，但是从局部上来看(两个Region区域)来看就是标记-复制算法，但是都不会产生空间碎片

#### 3.ZGC收集器

> ZGC是一款基于Region内存布局的，，不设分代的，使用了读屏障，染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

> 1. 基于Region的堆内存布局，但是ZGC的Region具有动态性-动态创建和销毁，以及动态的区域容量大小：有三种大小的容量(小型2M，用来放置小于256k的小对象)(中型32M,用来放置大于等于256k但是小于4m的对象)(大型容量不固定，可以动态变化，但是必须为2m的整数倍，用于放置4m以上的大对象。每个region中只存放一个大对象，大型Region再ZGC的实现中是不会被重分配的，因为复制一个大对象的代价是非常高的)
> 2. 并发整理算法的实现。ZGC用了读屏障。写屏障是在JIT中增强的一小段代码，会在使用指针获取对象地址的时候先根据着色指针判断这个时候获取是否安全，如果不安全，会等上一会再返回新的对象地址(获取新的对象地址的方式下面会说到)，读屏障只会在读取不安全的指针地址时使用，已经读取到的变量和非指针（基本数据类型）不会使用到读屏障。
> 3. 染色指针:《深入理解Java虚拟机》p115-118

> 步骤:
>
> 1. 并发标记:与G1一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过初始标记，最终标记的短暂暂停，而且这些停顿杰顿做的事情在目标上也是一样的。与G1不同的是,ZGC的标记是再指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked0,Mark1标志位
> 2. 并发预备分配:这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集。重分配集与G1收集器的回收集还是有区别的，ZGC划分Region的目的并非为了像G1做收益有限的增量回收。ZGC的重分配只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。此外，再JDK12的ZGC中开始支持类的卸载以及弱引用的处理，也是再这个阶段完成的。
> 3. 并发重分配:重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region中，并未重分配集中的每个Region维护与一个转发表，记录从旧对象到新对象的转向关系。得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问就会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的自愈能力。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。
> 4. 并发重映射:重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用
>
> 具体参考:《深入理解Java虚拟机》P117-118